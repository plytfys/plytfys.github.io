<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Java基础速览 | 回眸一笑Bug生</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="数据类型 基本类型 - 原生类：byte(1Byte)、short(2Byte)、int(4Byte)、long(8Byte)、char(2Byte)、boolean、float(4Byte)、double(8Byte) 引用类型  其中 float 声明时必须是 float f &#x3D; 1f​    数据类型 默认值    byte 0   short 0   int 0   long 0L   f">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础速览">
<meta property="og:url" content="https://plytfys.github.io/2023/11/01/code/Java%E5%9F%BA%E7%A1%80%E9%80%9F%E8%A7%88/index.html">
<meta property="og:site_name" content="回眸一笑Bug生">
<meta property="og:description" content="数据类型 基本类型 - 原生类：byte(1Byte)、short(2Byte)、int(4Byte)、long(8Byte)、char(2Byte)、boolean、float(4Byte)、double(8Byte) 引用类型  其中 float 声明时必须是 float f &#x3D; 1f​    数据类型 默认值    byte 0   short 0   int 0   long 0L   f">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/35902482/1686099594844-b67224c3-e814-4487-b2aa-f02d1cc9b355.png#averageHue=%23f7f7f6&clientId=u71b6ade1-8559-4&from=paste&id=ufbe15ebc&originHeight=272&originWidth=781&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=36628&status=done&style=none&taskId=u1ddb8cbf-2d9c-4e2c-a6d3-fc292d36f5d&title=">
<meta property="article:published_time" content="2023-11-01T09:44:52.272Z">
<meta property="article:modified_time" content="2023-11-01T09:45:37.249Z">
<meta property="article:author" content="xuyl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2023/png/35902482/1686099594844-b67224c3-e814-4487-b2aa-f02d1cc9b355.png#averageHue=%23f7f7f6&clientId=u71b6ade1-8559-4&from=paste&id=ufbe15ebc&originHeight=272&originWidth=781&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=36628&status=done&style=none&taskId=u1ddb8cbf-2d9c-4e2c-a6d3-fc292d36f5d&title=">
  
    <link rel="alternate" href="/atom.xml" title="回眸一笑Bug生" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">回眸一笑Bug生</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://plytfys.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-code/Java基础速览" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/01/code/Java%E5%9F%BA%E7%A1%80%E9%80%9F%E8%A7%88/" class="article-date">
  <time class="dt-published" datetime="2023-11-01T09:44:52.272Z" itemprop="datePublished">2023-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Java基础速览
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li><strong>基本类型 - 原生类：byte(1Byte)、short(2Byte)、int(4Byte)、long(8Byte)、char(2Byte)、boolean、float(4Byte)、double(8Byte)</strong></li>
<li><strong>引用类型</strong></li>
</ul>
<p>其中 float 声明时必须是 <code>float f = 1f</code>​</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>byte</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>short</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>int</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>long</strong></td>
<td><strong>0L</strong></td>
</tr>
<tr>
<td><strong>float</strong></td>
<td><strong>0.0f</strong></td>
</tr>
<tr>
<td><strong>double</strong></td>
<td><strong>0.0d</strong></td>
</tr>
<tr>
<td><strong>char</strong></td>
<td><strong>‘u0000’</strong></td>
</tr>
<tr>
<td><strong>String (or any object)</strong></td>
<td><strong>null</strong></td>
</tr>
<tr>
<td><strong>boolean</strong></td>
<td><strong>false</strong></td>
</tr>
</tbody></table>
<h1 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h1><p>封装、继承、多态</p>
<blockquote>
<p>多态：是指同一操作作用于不同的对象，可以产生不同的结果。运行期才能动态决定调用的子类方法。多态在 OOP 中实现了代码的灵活性和可扩展性，简化了程序的设计和实现。<br>多态的实现依赖于继承和重载重写。</p>
<p><code>重载和重写</code>​​ 不是面向对象的特征</p>
</blockquote>
<h1 id="访问修饰符-public，private，protected"><a href="#访问修饰符-public，private，protected" class="headerlink" title="访问修饰符 public，private，protected"></a>访问修饰符 public，private，protected</h1><p>public &gt; protected &gt; 默认（包级私有，默认不写也是包级私有） &gt; private</p>
<p>儿子是需要保护的，所以受保护的时候子类也是可以访问的<br>​<img src="https://cdn.nlark.com/yuque/0/2023/png/35902482/1686099594844-b67224c3-e814-4487-b2aa-f02d1cc9b355.png#averageHue=%23f7f7f6&clientId=u71b6ade1-8559-4&from=paste&id=ufbe15ebc&originHeight=272&originWidth=781&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=36628&status=done&style=none&taskId=u1ddb8cbf-2d9c-4e2c-a6d3-fc292d36f5d&title=" alt="image.png"></p>
<p><strong>private + get + set &#x3D; public ？？？？</strong><br>变量a被private修饰，同时提供了set、get方法。变量b被public修饰。乍一看这两种方式的实际效果并没有什么区别，都可以对变量操作，那么是不是说以后都可以直接用public修饰？<br>显然是不可行的。因为我们代码中的set、get方法基本都是自动生成的，在两个方法中并有特殊处理。如下例子中如果有处理那么就可以看到私有和公开的差异了。<br>私有的可以添加某些条件，二公开的可以直接修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">setA</span><span class="params">(String userCode, String a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(userCode.equals(<span class="string">&quot;sysAdmin&quot;</span>))&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>private + set + get的组合可以被final + 构造函数的组合替代，两种是相同的安全机制，并且后面的一种更为简洁。</strong></p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>构造函数和类名相同、没有返回值。普通方法也可以和构造方法同名。区别在于普通方法有返回值</p>
<p>一个类中至少有一个构造函数，默认的是无参构造函数。声明了就不会有无参构造函数了</p>
<p>继承时</p>
<ul>
<li>子类不会继承父类构造函数</li>
<li>子类构造函数第一行默认隐式调用super() （无参和有参构造函数都一样，当显式调用时，用的是显式调用的方法）</li>
</ul>
<blockquote>
<p>因为默认调用super()，所以有以下特点</p>
<p>1.通过子类构造函数创建子类时，想对应的super父类构造方法也会被创建</p>
<p>2.当子类中不显式调用super()时，必须确保父类中有无参构造函数</p>
</blockquote>
<p>如下代码就会编译报错，B的构造方法中会默认的调用super()，对应的就是父类的无参构造函数，因为A中已经声明了有参构造函数，所以不存在无参构造函数。因此会报错。需要显式的调用父类的有参构造函数<code>super(name);</code>​ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span> <span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;A-name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><ul>
<li><p>instanceof 可以防止转型失败</p>
<ul>
<li>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。</li>
</ul>
</li>
</ul>
<h1 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h1><ol>
<li><strong>静态变量、代码块只初始化一次</strong></li>
<li>静态变量初始化 -&gt; 静态代码块执行 -&gt; 实例成员变量初始化 -&gt; 实例代码块执行 -&gt; 构造方法执行</li>
</ol>
<p>当有父类时，先执行父类中的静态变量初始化 -&gt; 子类中的静态变量初始化，以此类推</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行实例代码块&quot;</span>);</span><br><span class="line">        number = <span class="number">10</span>; <span class="comment">// 初始化实例成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Example</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Example</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        <span class="comment">// 输出结果：</span></span><br><span class="line">        <span class="comment">// 执行实例代码块</span></span><br><span class="line">        <span class="comment">// 执行构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h1><p>静态方法中只能调用静态方法，但是不代表不可以调用非静态方法。</p>
<blockquote>
<p>可以在静态方法中通过 new 创建对象，然后通过对象来调用非静态方法</p>
</blockquote>
<p>interface 不能实例化所以没有实例变量，但是可以有静态变量，并且必须是 final 修饰，所以是 <code>public static final</code>。而在声明的时候有可以省略 <code>public static final</code> 所以可以直接声明成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">EMP_NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="comment">//编译的时候会编译成：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EMP_NAME</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是引用类型</p>
<h2 id="创建的几种方式"><a href="#创建的几种方式" class="headerlink" title="创建的几种方式"></a>创建的几种方式</h2><p>数组是有默认值的，所以数组创建的关键是<strong>指定数组的长度</strong>，通常使用前面两种方式<br>1、通过直接在[]指定长度<br>2、通过初始化参数间接指定长度<br>注意：不能同时在[]和{}中指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//下面三种本质上是一样的，都是在创建的时候初始化值</span></span><br><span class="line"><span class="type">int</span>[] b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line"><span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>数组创建后就不可改变，下面的虽然看起来像是改变了实际上第一次初始化的还在，只是无法获取到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>, <span class="number">6</span>&#125;;<span class="comment">//重新赋值，虽然a.length的长度变成了2，但是实际上还是没有改变</span></span><br><span class="line">System.out.println(a[<span class="number">0</span>]);</span><br><span class="line">System.out.println(a.length);</span><br></pre></td></tr></table></figure>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>子类继承父类时，修饰符访问不能更小，只能更大</p>
<h1 id="重载Overloading"><a href="#重载Overloading" class="headerlink" title="重载Overloading"></a>重载Overloading</h1><p>重载是指在<strong>同一个类</strong>中可以定义多个方法或构造函数，它们具有<strong>相同的名称</strong>但具<strong>有不同的参数列表</strong>。这些参数列表可以有不同的参数类型、不同的参数数量或不同的参数顺序。</p>
<p>重载是静态绑定的<br><strong>判断条件</strong>：</p>
<ol>
<li>参数个数不同</li>
<li>参数顺序不同</li>
<li>参数类型不同</li>
</ol>
<p><strong>注意</strong>：<code>重载方法可以有不同的修饰符、返回类型。但是这个不是判断是否重载的条件</code></p>
<h1 id="重写Overriding"><a href="#重写Overriding" class="headerlink" title="重写Overriding"></a>重写Overriding</h1><p>重写是指<strong>子类</strong>可以重新定义其父类中已存在的方法，以便在子类中提供不同的实现。重写<strong>方法的名称、返回类型和参数列表</strong>必须与父类中的原始方法相同。重写方法可以具有不同的方法体，从而实现不同的行为。重写通常用于实现子类对父类方法的特定行为定制。</p>
<p>重写是动态绑定的</p>
<p><strong>子类的访问修饰符权限只能比父类更宽松</strong></p>
<blockquote>
<p>确保子类方法不会缩小父类方法的可见性。</p>
<p>基于继承的本质，子类是对父类的扩展和特化，意味着子类应该能提供和父类相同的接口，如果范围更小很难提供相同的接口。</p>
<p>基于多态的实现，如果更小，无法实现多态性，父类引用在指向子类对象时，无法调用部分接口。</p>
</blockquote>
<p><strong>子类重写方法还可以修改返回值类型</strong></p>
<h1 id="静态绑定-动态绑定"><a href="#静态绑定-动态绑定" class="headerlink" title="静态绑定&amp;动态绑定"></a>静态绑定&amp;动态绑定</h1><h2 id="静态绑定（Static-Binding）"><a href="#静态绑定（Static-Binding）" class="headerlink" title="静态绑定（Static Binding）"></a><strong>静态绑定（Static Binding）</strong></h2><ul>
<li>静态绑定是在编译时发生的绑定过程。</li>
<li>对于重载（Overloading）方法，编译器在编译时能够确定要调用哪个方法，因为它根据方法的参数列表来选择正确的方法。这是因为参数列表在编译时是已知的。</li>
<li>静态绑定的示例：重载方法。编译器根据方法的参数类型、数量和顺序来选择正确的方法。</li>
</ul>
<h2 id="动态绑定（Dynamic-Binding）"><a href="#动态绑定（Dynamic-Binding）" class="headerlink" title="动态绑定（Dynamic Binding）"></a><strong>动态绑定（Dynamic Binding）</strong></h2><ul>
<li>动态绑定是在运行时发生的绑定过程，通常与多态性（Polymorphism）相关。</li>
<li>对于重写（Overriding）方法，编译器在编译时不能确定将调用哪个方法，因为它取决于实际对象的类型。编译器只能确定要调用的方法存在于对象的父类中，但具体执行哪个方法要在运行时根据对象的实际类型来确定。</li>
<li>动态绑定的示例：重写方法。在运行时，通过实际对象的类型来决定要调用的方法。</li>
</ul>
<h1 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>只能被继承，有抽象方法的类一定是抽象类，抽象类不一定有抽象方法</p>
<p><strong>定义方式</strong>：</p>
<ul>
<li>使用<code>abstract</code>​关键字定义的类，可以包含抽象方法（没有方法体的方法）和具体方法（有方法体的方法）。</li>
<li><strong>可以包含成员变量、构造方法等普通类的成员</strong>。</li>
<li>抽象类通常用于表示一种基本的类，它可以有一些通用的实现，但通常不会被实例化。</li>
</ul>
<p><strong>继承</strong>：</p>
<ul>
<li>其他类可以通过继承抽象类来获得它的特性和行为。</li>
<li>一个类只能继承一个抽象类，Java<strong>不支持多重继承</strong>。</li>
</ul>
<p><strong>构造方法</strong>：</p>
<ul>
<li>抽象类<strong>可以有</strong>构造方法，用于初始化对象，但无法直接实例化抽象类的对象。</li>
</ul>
<p><strong>用途</strong>：</p>
<ul>
<li>通常用于建模具有共同特性和行为的类的基类，提供一些通用的实现，但也可以包含抽象方法，要求子类实现特定行为。</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>可以被继承可以被实现</p>
<p><strong>定义方式</strong>：</p>
<ul>
<li>使用<code>interface</code>​关键字定义，<strong>只能包含</strong>抽象方法（没有方法体的方法）和常量（<code>static final</code>​变量）。</li>
<li>接口不能包含成员变量，普通方法，或构造方法。</li>
</ul>
<p><strong>实现</strong>：</p>
<ul>
<li>类可以通过使用<code>implements</code>​关键字实现接口，一个类可以实现多个接口，从而实现多继承的效果。</li>
</ul>
<p><strong>继承</strong>：</p>
<ul>
<li>接口之间可以使用<code>extends</code>​关键字来扩展其他接口，从而形成接口的继承关系。</li>
</ul>
<p><strong>用途</strong>：</p>
<ul>
<li>用于定义一组相关的操作，强制实现类提供特定的行为。接口常用于实现多态性，通过多个类实现同一个接口，可以以统一的方式调用这些类的方法。</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h5 id="设计思想的区别"><a href="#设计思想的区别" class="headerlink" title="设计思想的区别"></a><strong>设计思想的区别</strong></h5><p>接口是<strong>自上而下</strong>的抽象过程，接口<strong>规范了某些行为</strong>，是<strong>对某一行为的抽象</strong>。我需要这个行为，我就去实现某个接口，但是具体这个行为怎么实现，完全由自己决定。<br>抽象类是<strong>自下而上</strong>的抽象过程，抽象类<strong>提供了通用实现</strong>，是<strong>对某一类事物的抽象</strong>。我们在写实现类的时候，发现某些实现类具有几乎相同的实现，因此我们将这些相同的实现抽取出来成为抽象类，然后如果有一些差异点，则可以提供抽象方法来支持自定义实现。</p>
<h5 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h5><ul>
<li>抽象类：只能实现接口，只能继承一个抽象类，可以被继承。</li>
<li>接口：只能继承接口，从而实现多继承的效果。</li>
</ul>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><ul>
<li>抽象类：可以有构造方法，用于初始化对象。</li>
<li>接口：不能有构造方法，因为接口不能被实例化。</li>
</ul>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul>
<li>抽象类：可以包含成员变量，并且可以有各种访问控制修饰符。</li>
<li>接口：只能包含常量（public static final变量），不能包含实例变量。</li>
</ul>
<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><ul>
<li>抽象类：通过关键字<code>abstract</code>​​定义，使用<code>extends</code>​​关键字来继承。</li>
<li>接口：通过关键字<code>interface</code>​​定义，使用<code>implements</code>​​关键字来实现。</li>
</ul>
<h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><ul>
<li>抽象类：通常用于表示一种基本的类，并为其子类提供通用的实现，也可以包含一些默认的实现。</li>
<li>接口：用于定义一组相关的操作，强制实现类提供特定的行为，用于实现多态性。</li>
</ul>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="为什么使用内部类"><a href="#为什么使用内部类" class="headerlink" title="为什么使用内部类"></a>为什么使用内部类</h2><ul>
<li>封装和隐藏实现细节^1^</li>
<li><strong>既可以访问外部类的私有成员，同时不会将属性暴露给外部</strong></li>
</ul>
<p><strong>内部类的使用和调用普通方法一样。</strong></p>
<p><strong>内部类有外部类所有属性的访问权限，包括私有属性</strong></p>
<p><strong>内部类通过</strong> <code>OutClassName.this</code>​ 获取外部类实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> Class Outer&#123;</span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">         <span class="keyword">private</span> Outer <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> Outer.<span class="built_in">this</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建内部类的方式"><a href="#创建内部类的方式" class="headerlink" title="创建内部类的方式"></a>创建内部类的方式</h2><p>无论采用那种方式，都需要通过外部类创建（静态内部类除外，静态类不依赖实例）。所以是下面两种方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式。getInner方法为外部类方法，return new Inner();</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.getInner();</span><br><span class="line"><span class="comment">//第二种方式 通过.new 实现创建内部类</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br></pre></td></tr></table></figure>

<p>如果在外部类的非静态类方法中由于存在默认的 this 对象，所以可以直接 new Inner()，其他的都必须才如上面两种方式种的一种创建内部类</p>
<h2 id="Outer-this-和Outer-new"><a href="#Outer-this-和Outer-new" class="headerlink" title="Outer.this 和Outer.new"></a>Outer.this 和Outer.new</h2><p>通过.this 实现在内部类中创建外部类</p>
<blockquote>
<p>return Outer.this;</p>
</blockquote>
<p>通过.new 实现创建内部类</p>
<blockquote>
<p>new Outer.new Inner();</p>
</blockquote>
<p>[<strong>1</strong>]内部类将辅助类和实现细节封装在外部类中，从而隐藏了实现细节，减少外部类的复杂性。外部类和外部代码无法直接访问和操作这些实现细节，降低耦合度。 - 外部类和外部代码必须先获取内部类对象才能调用内部类方法（也是和直接在外部类中写内部类的方法的区别）</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>要继承一个父类或者实现一个接口，也仅能继承一个父类或者实现一个接口，通过 new 关键字实现，后面可以用 lambda 表达式写</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="创建了几个对象"><a href="#创建了几个对象" class="headerlink" title="创建了几个对象"></a>创建了几个对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在常量池中首先看看有没有变量，如果没有创建一个</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//创建一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建1个或者2两，当常量池没有abc时，在常量池中创建一个，同时再在堆中创建一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个字符串相加的会被优化，而不是创建两个</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span> + <span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="和-equals"><a href="#和-equals" class="headerlink" title="&#x3D;&#x3D;和 equals"></a>&#x3D;&#x3D;和 equals</h2><p>&#x3D;&#x3D;：判断的是引用地址<br>equals：判断的是实际的值，要用这种方式<br>下面这种情况要注意，都会输出 true，但是这只是巧合。因为创建 b 时常量池中已经有了 Hello 所以不会在重新创建对象，a 和 b 共用的一个，所以&#x3D;&#x3D;是 true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(a.equals(b));</span><br></pre></td></tr></table></figure>

<h2 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h2><p>注意 s 不是大写。左闭右开。<br>substring(2, 4)：从下标为 2 开始取到 4，为 4 的下标不取</p>
<h2 id="去除空字符串"><a href="#去除空字符串" class="headerlink" title="去除空字符串"></a>去除空字符串</h2><p>trim()：移除字符串首尾空白字符。空白字符包括空格，\t，\r，\n<br>strip()：移除字符串首尾空白字符。它和 trim()不同的是，类似中文的空格字符\u3000 也会被移除</p>
<h2 id="isEmpty-和-isBlank"><a href="#isEmpty-和-isBlank" class="headerlink" title="isEmpty()和 isBlank()"></a>isEmpty()和 isBlank()</h2><ul>
<li><p>当字符串为 null 时</p>
<ul>
<li>都返回 true</li>
</ul>
</li>
<li><p>不为 null 时</p>
<ul>
<li>isEmpty 判断 <code>是否为空&quot;&quot;</code>，即字符串长度是否为 0。”  “ -&gt; false</li>
<li>isBlank 判断 <code>是否是空串&quot; &quot;</code>，长度为 3 的空串返回也是 true。”  “ -&gt; true</li>
</ul>
</li>
</ul>
<h1 id="字符串拼接-StringJoiner、String-join"><a href="#字符串拼接-StringJoiner、String-join" class="headerlink" title="字符串拼接 StringJoiner、String.join"></a>字符串拼接 StringJoiner、String.join</h1><p>两个都可以用来拼接字符串，当没有开头和结尾时用 String.join 更方便</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//上面的数组以, 分割</span></span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">stringJoiner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="comment">//以, 分割，以hello开头，以！结尾</span></span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">stringJoiner2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String name : names) &#123;</span><br><span class="line">    stringJoiner.add(name);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(stringJoiner.toString());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> String.join(<span class="string">&quot;, &quot;</span>, names);</span><br><span class="line">System.out.println(join);</span><br></pre></td></tr></table></figure>

<h1 id="JavaBean遍历"><a href="#JavaBean遍历" class="headerlink" title="JavaBean遍历"></a>JavaBean遍历</h1><p>有被private修饰的属性，以及有public修饰的get，set方法的叫做JavaBean</p>
<p>使用Introspector可以枚举JavaBean的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.BeanInfo;</span><br><span class="line"><span class="keyword">import</span> java.beans.IntrospectionException;</span><br><span class="line"><span class="keyword">import</span> java.beans.Introspector;</span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> uSelf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/9/24 20:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BeanInfo</span> <span class="variable">beanInfo</span> <span class="operator">=</span> Introspector.getBeanInfo(Emp.class);</span><br><span class="line">            PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors();</span><br><span class="line">            <span class="keyword">for</span>(PropertyDescriptor pd : descriptors) &#123;</span><br><span class="line">                <span class="comment">//获取属性名称</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pd.getName();</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="comment">//获取读方法</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">readMethod</span> <span class="operator">=</span> pd.getReadMethod();</span><br><span class="line">                System.out.println(<span class="string">&quot;    &quot;</span> + readMethod);</span><br><span class="line">                <span class="comment">//获取写方法</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">writeMethod</span> <span class="operator">=</span> pd.getWriteMethod();</span><br><span class="line">                System.out.println(<span class="string">&quot;    &quot;</span> + writeMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IntrospectionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String empCode;</span><br><span class="line">    <span class="keyword">private</span> String empName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmpCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> empCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmpCode</span><span class="params">(String empCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.empCode = empCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmpName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> empName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmpName</span><span class="params">(String empName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.empName = empName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class</span><br><span class="line">    public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">    null</span><br><span class="line">empCode</span><br><span class="line">    public java.lang.String Emp.getEmpCode()</span><br><span class="line">    public void Emp.setEmpCode(java.lang.String)</span><br><span class="line">empName</span><br><span class="line">    public java.lang.String Emp.getEmpName()</span><br><span class="line">    public void Emp.setEmpName(java.lang.String)</span><br></pre></td></tr></table></figure>

<p>其中class是JavaBean从Object继承过来的</p>
<h1 id="并发、同步和异步"><a href="#并发、同步和异步" class="headerlink" title="并发、同步和异步"></a>并发、同步和异步</h1><ol>
<li>并发（Concurrency）：并发指的是<strong>多个任务可以同时执行的能力</strong>。在计算机中，有多个任务可以在同一时间段内执行，并且它们可以是同时进行的，这种情况称为并发。并发可以通过多线程或多进程来实现，它可以提高系统的吞吐量和响应性。</li>
<li>同步（Synchronization）：同步指的是<strong>多个任务之间按照特定的顺序执行，每个任务等待前一个任务完成后再执行。</strong> 在同步的场景中，任务之间需要互相协调和通信，以确保按照特定的顺序执行。常见的同步机制包括互斥锁（mutex）、信号量（semaphore）、条件变量（condition variable）等。</li>
<li>异步（Asynchronization）：异<strong>步指的是任务的执行是相互独立的，不需要等待前一个任务完成</strong>。在异步的场景中，任务可以独立执行，不需要等待其他任务的结果。异步执行通常通过回调函数、事件驱动或者异步编程模型来实现，它可以提高系统的并发性和响应性。</li>
</ol>
<p>同步和异步都属于并发，都是多个任务同时执行，只不过具体实现不同<br>并发：是多个用户同时访问一个资源<br>并行：一边吃饭一边打电话</p>
<h1 id="值存放地址"><a href="#值存放地址" class="headerlink" title="值存放地址"></a>值存放地址</h1><p>基本类型数据值存放在栈中，引用类型数据值存放在堆中<br>类的成员变量（也属于对象）存放在堆中，静态变量存放在方法区</p>
<h1 id="Java连接数据库"><a href="#Java连接数据库" class="headerlink" title="Java连接数据库"></a>Java连接数据库</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xu.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mysql.jdbc.Driver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> JDBCDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xuyuanliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/2/14 8:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			1.注册驱动</span></span><br><span class="line"><span class="comment">			2.获取连接</span></span><br><span class="line"><span class="comment">			3.获取预编译Statement</span></span><br><span class="line"><span class="comment">			4.执行sql</span></span><br><span class="line"><span class="comment">			5.关闭连接</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/xuylDb&quot;</span>,</span><br><span class="line">				<span class="string">&quot;root&quot;</span>,</span><br><span class="line">				<span class="string">&quot;xuyl3531&quot;</span>);</span><br><span class="line">		<span class="comment">//可能会有sql注入</span></span><br><span class="line">		<span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">		<span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(<span class="string">&quot;select * from st_user&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">			System.out.println(resultSet.getString(<span class="string">&quot;user_code&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//预编译sql，解决sql注入</span></span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;select * from st_user where user_code = ?&quot;</span>);</span><br><span class="line">		preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;20220214&quot;</span>);</span><br><span class="line">		<span class="type">ResultSet</span> <span class="variable">resultSet1</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line">		<span class="keyword">while</span> (resultSet1.next()) &#123;</span><br><span class="line">			System.out.println(resultSet1.getString(<span class="string">&quot;user_code&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		resultSet.close();</span><br><span class="line">		resultSet1.close();</span><br><span class="line">		statement.close();</span><br><span class="line">		preparedStatement.close();</span><br><span class="line">		connection.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>‍</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://plytfys.github.io/2023/11/01/code/Java%E5%9F%BA%E7%A1%80%E9%80%9F%E8%A7%88/" data-id="clofkzly90000nstqfvwdas0d" data-title="Java基础速览" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/10/31/ERP%E5%92%8CBPM/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">ERP和BPM</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/01/code/Java%E5%9F%BA%E7%A1%80%E9%80%9F%E8%A7%88/">Java基础速览</a>
          </li>
        
          <li>
            <a href="/2023/10/31/ERP%E5%92%8CBPM/">ERP和BPM</a>
          </li>
        
          <li>
            <a href="/2023/10/31/%E4%B8%80%E4%B8%AADemo/">一个Demo</a>
          </li>
        
          <li>
            <a href="/2023/10/31/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 xuyl<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>